<!DOCTYPE html><html><head>
<meta charset="utf-8" />
<link href="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.css" rel="stylesheet">
<script src="https://unpkg.com/maplibre-gl@5.6.0/dist/maplibre-gl.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.9"></script>
<style>
  html,body,#map{height:100%;margin:0;}
  .maplibregl-popup-content {
    padding: 15px;
    min-width: 480px;
  }
  /* Loading indicator styles */
  #loading {
    position: absolute;
    width: 100%;
    height: 100%;
    background-color: rgba(255,255,255,0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999;
    font-size: 24px;
    color: #333;
  }
  .spinner {
    border: 5px solid #f3f3f3;
    border-top: 5px solid #3498db;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 2s linear infinite;
    margin-right: 20px;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>
</head>
<body>
<div id="map"></div>
<div id="loading"><div class="spinner"></div>Loading 200,000+ hazard points...</div>
<script>
// Configure API base URL
const apiBaseUrl = window.location.hostname === 'localhost' 
  ? 'http://localhost:5000' 
  : '/api';

const map = new maplibregl.Map({
  container: 'map',
  style: {
    'version': 8,
    'sources': {
      'osm': {
        'type': 'raster',
        'tiles': ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
        'tileSize': 256,
        'attribution': 'Â© OpenStreetMap contributors'
      }
    },
    'layers': [
      {
        'id': 'osm',
        'type': 'raster',
        'source': 'osm',
        'minzoom': 0,
        'maxzoom': 19
      }
    ]
  },
  center: [0, 20],
  zoom: 2,
  maxZoom: 19,
  preserveDrawingBuffer: true // Important for performance with many points
});

// Function to fetch all points using vector tiles
map.on('load', async () => {
  // Add controls
  map.addControl(new maplibregl.NavigationControl(), 'top-right');
  
  // Add regular points collection first
  const pointsData = await fetchAllPoints();
  map.addSource('pts', {
    type: 'geojson',
    data: pointsData
  });
  
  map.addLayer({
    id: 'pt', 
    type: 'circle', 
    source: 'pts',
    paint: {
      'circle-radius': 5, 
      'circle-color': '#FF0000', 
      'circle-stroke-width': 1, 
      'circle-stroke-color': '#FFFFFF'
    }
  });

  // Add hazard points using vector tiles for optimal performance
  try {
    // Check if tiles endpoint exists
    const response = await fetch(`${apiBaseUrl}/collections/hazard_points_fgb/tiles`);
    if (!response.ok) {
      throw new Error('Tiles endpoint not available');
    }
    
    // Add vector tiles source
    map.addSource('hazard-pts', {
      type: 'vector',
      tiles: [`${apiBaseUrl}/collections/hazard_points_fgb/tiles/WebMercatorQuad/{z}/{y}/{x}?f=mvt`],
      minzoom: 0,
      maxzoom: 15
    });
    
    // Add hazard points layer with optimized rendering
    map.addLayer({
      id: 'hazard-pt', 
      type: 'circle', 
      source: 'hazard-pts',
      'source-layer': 'GlobalHazardPoints', // Must match the layer name in FlatGeobuf
      paint: {
        'circle-radius': [
          'interpolate', ['linear'], ['zoom'],
          0, 1,   // Very small at world view
          10, 3,  // Medium at city level
          15, 5   // Full size when zoomed in
        ],
        'circle-color': '#0066FF',
        'circle-opacity': 0.7, // Slight transparency helps with overlapping points
        'circle-stroke-width': [
          'interpolate', ['linear'], ['zoom'],
          0, 0,   // No stroke at world view
          10, 0.5, // Thin stroke at medium zoom
          15, 1   // Full stroke when zoomed in
        ],
        'circle-stroke-color': '#FFFFFF'
      }
    });

    // Add heat map layer for better overview of density
    map.addLayer({
      id: 'hazard-heat',
      type: 'heatmap',
      source: 'hazard-pts',
      'source-layer': 'GlobalHazardPoints',
      paint: {
        'heatmap-weight': 1,
        'heatmap-intensity': [
          'interpolate', ['linear'], ['zoom'],
          0, 1,
          9, 3
        ],
        'heatmap-color': [
          'interpolate', ['linear'], ['heatmap-density'],
          0, 'rgba(0, 0, 255, 0)',
          0.2, 'rgba(0, 0, 255, 0.2)',
          0.4, 'rgba(0, 0, 255, 0.4)',
          0.6, 'rgba(0, 102, 255, 0.6)',
          0.8, 'rgba(0, 179, 255, 0.8)',
          1, 'rgba(0, 255, 255, 1)'
        ],
        'heatmap-radius': [
          'interpolate', ['linear'], ['zoom'],
          0, 2,
          9, 20
        ],
        'heatmap-opacity': [
          'interpolate', ['linear'], ['zoom'],
          7, 1,
          9, 0
        ]
      },
      maxzoom: 9
    });

    // Hide loading indicator once loaded
    document.getElementById('loading').style.display = 'none';
    
  } catch (error) {
    console.error("Vector tiles not supported:", error);
    alert("Unable to load all 200,000 points efficiently. Please check server configuration.");
  }

  // Click handler for hazard points
  map.on('click', 'hazard-pt', e => {
    const properties = e.features[0].properties;
    
    // Create table of properties
    let html = '<h3>Hazard Point</h3><table style="width:100%">';
    for (const [key, value] of Object.entries(properties)) {
      if (key !== 'id' && key !== 'fid') {
        html += `<tr><td><strong>${key}</strong></td><td>${value}</td></tr>`;
      }
    }
    html += '</table>';
    
    new maplibregl.Popup({
      maxWidth: '500px',
      className: 'chart-popup'
    })
    .setLngLat(e.lngLat)
    .setHTML(html)
    .addTo(map);
  });
  
  // Set cursor style on point hover
  map.on('mouseenter', 'hazard-pt', () => {
    map.getCanvas().style.cursor = 'pointer';
  });
  
  map.on('mouseleave', 'hazard-pt', () => {
    map.getCanvas().style.cursor = '';
  });
});

// Function to fetch all regular points
async function fetchAllPoints() {
  let allFeatures = [];
  let nextLink = `${apiBaseUrl}/collections/points/items?f=json&limit=100`;
  
  while (nextLink) {
    const response = await fetch(nextLink);
    const data = await response.json();
    
    if (data.features && data.features.length > 0) {
      allFeatures = allFeatures.concat(data.features);
    }
    
    nextLink = null;
    if (data.links) {
      const nextLinkObj = data.links.find(link => link.rel === 'next');
      if (nextLinkObj) {
        nextLink = nextLinkObj.href;
      }
    }
  }
  
  return {
    type: 'FeatureCollection',
    features: allFeatures
  };
}
</script></body></html>
